<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PyCharm Clone</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: Arial, sans-serif;
    background-color: #2b2b2b;
    color: #a9b7c6;
    overflow: hidden;
  }

  .container {
    display: flex;
    height: 100%;
  }

  .sidebar {
    width: 15%;
    background-color: #313335;
    border-right: 1px solid #4e4e4e;
    display: flex;
    flex-direction: column;
    padding: 10px;
    overflow-y: auto;
  }

  .sidebar h2 {
    margin-top: 0;
    font-size: 14px;
    color: #a9b7c6;
    border-bottom: 1px solid #4e4e4e;
    padding-bottom: 10px;
  }

  .sidebar ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .sidebar ul li {
    margin: 10px 0;
  }

  .sidebar ul li a {
    text-decoration: none;
    color: #a9b7c6;
    font-size: 13px;
  }

  .editor-container {
    width: 85%;
    display: flex;
    flex-direction: column;
  }

  .toolbar {
    height: 30px;
    background-color: #3c3f41;
    display: flex;
    align-items: center;
    padding: 0 10px;
    border-bottom: 1px solid #4e4e4e;
    font-size: 13px;
  }

  .toolbar span {
    margin-right: 15px;
    color: #a9b7c6;
    cursor: pointer;
  }

  .tabs {
    display: flex;
    height: 30px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #4e4e4e;
    align-items: center;
    padding-left: 10px;
  }

  .tabs div {
    padding: 0 15px;
    background-color: #3c3f41;
    margin-right: 5px;
    border-radius: 3px 3px 0 0;
    color: #a9b7c6;
    cursor: pointer;
    display: flex;
    align-items: center;
  }

  .tabs div.active {
    background-color: #2b2b2b;
  }

  .tabs div:hover {
    background-color: #4e5052;
  }

  .code-area {
    flex-grow: 1;
    background-color: #2b2b2b;
    color: #a9b7c6;
    padding: 20px;
    overflow-y: auto;
  }

  .code-area textarea {
    width: 100%;
    height: 100%;
    background-color: #2b2b2b;
    color: #a9b7c6;
    border: none;
    resize: none;
    outline: none;
    font-family: "Courier New", Courier, monospace;
    font-size: 14px;
  }

  .status-bar {
    height: 20px;
    background-color: #313335;
    border-top: 1px solid #4e4e4e;
    display: flex;
    align-items: center;
    padding: 0 10px;
    font-size: 12px;
    color: #a9b7c6;
  }

  .status-bar div {
    margin-right: 20px;
  }
</style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h2>Project</h2>
      <ul>
        <li><a href="#">main.py</a></li>
        <li><a href="#">index.html</a></li>
        <li><a href="#">style.css</a></li>
      </ul>
    </div>
    <div class="editor-container">
      <div class="toolbar">
        <span>File</span>
        <span>Edit</span>
        <span>View</span>
        <span>Navigate</span>
        <span>Code</span>
        <span>Run</span>
        <span>Tools</span>
        <span>VCS</span>
        <span>Window</span>
        <span>Help</span>
      </div>
      <div class="tabs">
        <div class="active">main.py</div>
        <div>index.html</div>
        <div>style.css</div>
      </div>
      <div class="code-area">
        <textarea spellcheck="false">//ALGORITHM LAB
            1.
            import timeit
            import matplotlib.pyplot as plt
            # Input Array elments
            def Input(Array, n):
            # iterating till the range
            for i in range(0, n):
            ele = int(input("Arr : "))
            # adding the element
            Array.append(ele)
            # Linear Searching
            def linear_search(Array, key):
            for x in Array:
            if x == key:
            return True
            return False
            # Main Block()
            N = []
            CPU = []
            trail = int(input("Enter no. of trails : "))
            for t in range(0, trail):
            Array = []
            print("-----> TRAIL NO : ", t + 1)
            n = int(input("Enter number of elements : "))
            Input(Array, n)
            print(Array)
            key = int(input("Enter key :"))
            start = timeit.default_timer()
            s = linear_search(Array, key)
            print("Element Found = ", s)
            times = timeit.default_timer() - start
            N.append(n)
            CPU.append(round(float(times) * 1000000, 2))
            print("N CPU")
            for t in range(0, trail):
            print(N[t], CPU[t])
            # Plotting Graph
            plt.plot(N, CPU)
            plt.scatter(N, CPU, color= "red", marker= "*", s=50)
            # naming the x axis
            plt.xlabel('Array Size - N')
            # naming the y axis
            plt.ylabel('CPU Processing Time')
            # giving a title to graph
            plt.title('Linear Search Time efficiency')
            # function to show the plot
            plt.show()

            2.
            import timeit
            import matplotlib.pyplot as plt
            # Input Array elments
            def Input(Array, n):
            # iterating till the range
            for i in range(0, n):
            ele = int(input("Arr : "))
            # adding the element
            Array.append(ele)
            # Binary Searching
            def binary_search(Array, key):
            while len(Array) > 0:
            mid = (len(Array))//2
            if Array[mid] == key:
            return True
            elif Array[mid] < key:
            Array = Array[:mid]
            else:
            Array = Array[mid + 1:]
            return False
            # Main Block()
            N = []
            CPU = []
            trail = int(input("Enter no. of trails : "))
            for t in range(0, trail):
            Array = []
            print("-----> TRAIL NO : ", t + 1)
            n = int(input("Enter number of elements : "))
            Input(Array, n)
            print(Array)
            key = int(input("Enter key :"))
            start = timeit.default_timer()
            s = binary_search(Array, key)
            print("Element Found = ", s)
            times = timeit.default_timer() - start
            N.append(n)
            CPU.append(round(float(times) * 1000000, 2))
            print("N CPU")
            for t in range(0, trail):
            print(N[t], CPU[t])
            # Plotting Graph
            plt.plot(N, CPU)
            plt.scatter(N, CPU, color= "red", marker= "*", s=50)
            # naming the x axis
            plt.xlabel('Array Size - N')
            # naming the y axis
            plt.ylabel('CPU Processing Time')
            # giving a title to graph
            plt.title('Binary Search Time efficiency')
            # function to show the plot
            plt.show()
        
            3.
            # Recursive Python function to solve the tower of hanoi
            def TowerOfHanoi(n, source, destination, auxiliary):
            if n == 1:
            print("Move disk 1 from source", source, "to destination", destination)
            return
            TowerOfHanoi(n - 1, source, auxiliary, destination)
            print("Move disk", n, "from source", source, "to destination", destination)
            TowerOfHanoi(n - 1, auxiliary, destination, source)
            # Main Block
            n=int(input("Enter number of disk : "))
            TowerOfHanoi(n, 'A', 'B', 'C')
            
            4.

            import timeit
            import random
            import matplotlib.pyplot as plt
            # Input Array elements
            def Input(Array, n):
            # iterating till the range
            for i in range(0, n):
            ele = random.randrange(1,50)
            # adding the element
            Array.append(ele)
            # Selection Sort
            def selectionSort(Array, size):
            for ind in range(size):
            min_index = ind
            for j in range(ind + 1, size):
            # select the minimum element in every iteration
            if Array[j] < Array[min_index]:
            min_index = j
            # swapping the elements to sort the array
            (Array[ind], Array[min_index]) = (Array[min_index], Array[ind])
            # Main Block()
            N = []
            CPU = []
            trail = int(input("Enter no. of trails : "))
            for t in range(0, trail):
            Array = []
            print("-----> TRAIL NO : ", t + 1)
            n = int(input("Enter number of elements : "))
            Input(Array, n)
            start = timeit.default_timer()
            selectionSort(Array,n)
            times = timeit.default_timer() - start
            print("Sorted Array :")
            print(Array)
            N.append(n)
            CPU.append(round(float(times) * 1000000, 2))
            print("N CPU")
            for t in range(0, trail):
            print(N[t], CPU[t])
            # Plotting Graph
            plt.plot(N, CPU)
            plt.scatter(N, CPU, color= "red", marker= "*", s=50)
            # naming the x axis
            plt.xlabel('Array Size - N')
            # naming the y axis
            plt.ylabel('CPU Processing Time')
            # giving a title to graph
            plt.title('Selection Sort Time efficiency')
            # function to show the plot
                        plt.show()


            5.
                # Brute force method
                #A simple solution to calculate pow(a, n) would multiply a exactly n times. We can do that by
                using a simple for loop
                def bpower(a, n):
                pow = 1
                for i in range(n):
                pow = pow * a
                return pow
                # Divide and Conquer method
                #The problem can be recursively defined by:
                # dpower(x, n) = dpower(x, n / 2) * dpower(x, n / 2); // if n is even
                # dpower(x, n) = x * dpower(x, n / 2) * dpower(x, n / 2); // if n is odd
                def dpower(x, y):
                if (y == 0):
                return 1
                elif (int(y % 2) == 0):
                return (dpower(x, int(y / 2)) *
                dpower(x, int(y / 2)))
                else:
                return (x * dpower(x, int(y / 2)) *
                dpower(x, int(y / 2)))
                # Main block
                a=int(input("Enter a :"))
                n=int(input("Enter n :"))
                print("Brute Force method a^n : ",bpower(a,n))
                print("Divide and Conquer a^n : ",dpower(a,n))
                6.
               
              import timeit
              import random
              import matplotlib.pyplot as plt
              # Input Array elments
              def Input(Array, n):
              # iterating till the range
              for i in range(0, n):
              ele = random.randrange(1,50)
              # adding the element
              Array.append(ele)
              # divide function
              def partition(Array,low,high):
              i = ( low-1 )
              pivot = Array[high] # pivot element
              for j in range(low , high):
              # If current element is smaller
              if Array[j] <= pivot:
              # increment
              i = i+1
              Array[i],Array[j] = Array[j],Array[i]
              Array[i+1],Array[high] = Array[high],Array[i+1]
              return ( i+1 )
              # Quick sort
              def quickSort(Array,low,high):
              if low < high:
              # index
              pi = partition(Array,low,high)
              # sort the partitions
              quickSort(Array, low, pi-1)
              quickSort(Array, pi+1, high)
              # Main Block()
              N = []
              CPU = []
              trail = int(input("Enter no. of trails : "))
              for t in range(0, trail):
              Array = []
              print("-----> TRAIL NO : ", t + 1)
              n = int(input("Enter number of elements : "))
              Input(Array, n)
              start = timeit.default_timer()
              quickSort(Array,0,n-1)
              times = timeit.default_timer() - start
              print("Sorted Array :")
              print(Array)
              N.append(n)
              CPU.append(round(float(times) * 1000000, 2))
              print("N CPU")
              for t in range(0, trail):
              print(N[t], CPU[t])
              # Plotting Graph
              plt.plot(N, CPU)
              plt.scatter(N, CPU, color= "red", marker= "*", s=50)
              # naming the x axis
              plt.xlabel('Array Size - N')
              # naming the y axis
              plt.ylabel('CPU Processing Time')
              # giving a title to graph
              plt.title('Quick Sort Time efficiency')
             plt.show()

             7.
                            
                # Brute force method
                #The value of C(n, k) can be recursively calculated using the following standard formula
                for Binomial Coefficients.
                # C(n, k) = C(n-1, k-1) + C(n-1, k)
                # C(n, 0) = C(n, n) = 1
                def binomialCoeff_BF(n, k):
                if k > n:
                return 0
                if k == 0 or k == n:
                return 1
                # Recursive Call
                return binomialCoeff_BF(n - 1, k - 1) + binomialCoeff_BF(n - 1, k)
                # Divide and Conquer method
                #re-computations of the same subproblems can be avoided by constructing a temporary
                2D-array C[][] in a bottom-up manner.
                # uses Overlapping Subproblems concept
                def binomialCoef_DC(n, k):
                C = [[0 for x in range(k + 1)] for x in range(n + 1)]
                # Calculate value of Binomial
                # Coefficient in bottom up manner
                for i in range(n + 1):
                for j in range(min(i, k) + 1):
                # Base Cases
                if j == 0 or j == i:
                C[i][j] = 1
                # Calculate value using
                # previously stored values
                else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
                return C[n][k]
                # Main block
                n=int(input("Enter n :"))
                k=int(input("Enter k :"))
                print("Brute Force method n^k : ",binomialCoeff_BF(n, k))
                print("Divide and Conquer n^k : ",binomialCoef_DC(n, k))

                
                9. Write a program to evaluate polynomial using brute-force algorithm and using
              Horner’s rule and compare their performances.
              import timeit
              def polynomial_BF(poly,x,n):
              # Declaring the result
              result = 0
              # Running a for loop to traverse through the list
              for i in range(n):
              # Declaring the variable Sum
              Sum = poly[i]
              # Running a for loop to multiply x (n-i-1)
              # times to the current coefficient
              for j in range(n - i - 1):
              Sum = Sum * x
              # Adding the sum to the result
              result = result + Sum
              # Printing the result
              print("Value of polynomial 2x3 - 6x2 + 2x - 1 for x = 3 using [BRUTE FORCE method ]
              :",result)
              def horner(poly, x, n):
              # Initialize result
              res = poly[0]
              # Evaluate value of polynomial
              # using Horner's method
              for i in range(1, n):
              res = res * x + poly[i]
              print("Value of polynomial 2x3 - 6x2 + 2x - 1 for x = 3 using [HORNER method ] :",
              res)
              #Main block
              # 2x3 - 6x2 + 2x - 1 for x = 3
              poly = [2, -6, 2, -1]
              x = 3
              n = len(poly)
              start1 = timeit.default_timer()
              polynomial_BF(poly,x,n)
              t1 = timeit.default_timer() - start1
              start2 = timeit.default_timer()
              horner(poly,x,n)
              t2 = timeit.default_timer() - start2
              print("Time complexity of Brute force method O(n2) : ",t1)
              print("Time complexity of Horner method O(n) : ",t2) 

              12.
              12.Write a program to implement BFS traversal algorithm.
            graph = {
            '5' : ['3','7'],
            '3' : ['2', '4'],
            '7' : ['8'],
            '2' : [],
            '4' : ['8'],
            '8' : []
            }
            visited = [] # List for visited nodes.
            queue = [] #Initialize a queue
            def bfs(visited, graph, node): #function for BFS
            visited.append(node)
            queue.append(node)
            while queue: # Creating loop to visit each node
            m = queue.pop(0)
            print (m, end = " ")
            for neighbour in graph[m]:
            if neighbour not in visited:
            visited.append(neighbour)
            queue.append(neighbour)
            # Main module
            print("Following is the Breadth-First Search")
            bfs(visited, graph, '5')

            15.Write a program to find subset of a given set S={s1,s2,….sn} of n positive
integers whose sum is equal to given positive integer d. For example if
S={1,2,5,6,8} and d=9 then two solutions {1,2,6} and {1,8}. A suitable message is to
be displayed if given problem doesn’t have solution.
from itertools import combinations
              def Input(S, n):
              # iterating till the range
              for i in range(0, n):
              ele = int(input("Arr : "))
              # adding the element
              S.append(ele)
              def sub_set_sum(size, S, sub_set_sum):
              count=0
              for i in range(size+1):
              for my_sub_set in combinations(S, i):
              if sum(my_sub_set) == d:
              print(list(my_sub_set))
              count=count+1
              if(count==0) :
              print("Subset Not found for the given d=",d)
              #Main module
              S = []
              n = int(input("Enter size :"))
              Input(S, n)
              print(S)
              d = int(input("Enter sum d :"))
              print("The result is :")
              sub_set_sum(n, S, d)




            </textarea>
      </div>
      <div class="status-bar">
        <div>Line: 1</div>
        <div>Column: 1</div>
        <div>Python 3.8</div>
        <div>Spaces: 4</div>
        <div>UTF-8</div>
      </div>
    </div>
  </div>
</body>
</html>
